// Package gateway provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package gateway

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

const (
	UserIdHeaderAuthScopes = "UserIdHeaderAuth.Scopes"
)

// Defines values for OrderStatus.
const (
	CANCELLED OrderStatus = "CANCELLED"
	FINISHED  OrderStatus = "FINISHED"
	NEW       OrderStatus = "NEW"
)

// CreateAccountRequest Empty request body. user_id is taken from X-User-Id header, or generated by gateway if missing.
type CreateAccountRequest = map[string]interface{}

// CreateAccountResponse defines model for CreateAccountResponse.
type CreateAccountResponse struct {
	Balance int64 `json:"balance"`

	// UserId Resolved user id (provided or generated by gateway).
	UserId string `json:"user_id"`
}

// CreateOrderRequest defines model for CreateOrderRequest.
type CreateOrderRequest struct {
	Amount      int64  `json:"amount"`
	Description string `json:"description"`
}

// CreateOrderResponse defines model for CreateOrderResponse.
type CreateOrderResponse struct {
	Order Order `json:"order"`

	// UserId Resolved user id (provided or generated by gateway).
	UserId string `json:"user_id"`
}

// ErrorResponse defines model for ErrorResponse.
type ErrorResponse struct {
	Details *map[string]interface{} `json:"details,omitempty"`
	Error   string                  `json:"error"`

	// UserId Resolved user id (provided or generated by gateway), if available.
	UserId *string `json:"user_id,omitempty"`
}

// GetBalanceResponse defines model for GetBalanceResponse.
type GetBalanceResponse struct {
	Balance int64 `json:"balance"`

	// UserId User id from request header.
	UserId string `json:"user_id"`
}

// GetOrderResponse defines model for GetOrderResponse.
type GetOrderResponse struct {
	Order Order `json:"order"`

	// UserId Resolved user id (provided or generated by gateway).
	UserId string `json:"user_id"`
}

// ListOrdersResponse defines model for ListOrdersResponse.
type ListOrdersResponse struct {
	Orders []Order `json:"orders"`

	// UserId Resolved user id (provided or generated by gateway).
	UserId string `json:"user_id"`
}

// Order defines model for Order.
type Order struct {
	// Amount Amount in minimal currency units (e.g. cents/kopecks).
	Amount      int64       `json:"amount"`
	CreatedAt   *time.Time  `json:"created_at,omitempty"`
	Description string      `json:"description"`
	OrderId     string      `json:"order_id"`
	Status      OrderStatus `json:"status"`
	UserId      string      `json:"user_id"`
}

// OrderStatus defines model for OrderStatus.
type OrderStatus string

// TopUpAccountRequest defines model for TopUpAccountRequest.
type TopUpAccountRequest struct {
	// Amount Amount in minimal currency units (e.g. cents/kopecks).
	Amount int64 `json:"amount"`
}

// TopUpAccountResponse defines model for TopUpAccountResponse.
type TopUpAccountResponse struct {
	Balance int64 `json:"balance"`

	// UserId Resolved user id (provided or generated by gateway).
	UserId string `json:"user_id"`
}

// IdempotencyKeyHeader defines model for IdempotencyKeyHeader.
type IdempotencyKeyHeader = string

// LimitQuery defines model for LimitQuery.
type LimitQuery = int32

// OrderIdPath defines model for OrderIdPath.
type OrderIdPath = string

// PageTokenQuery defines model for PageTokenQuery.
type PageTokenQuery = string

// UserIdHeader defines model for UserIdHeader.
type UserIdHeader = string

// UserIdHeaderRequired defines model for UserIdHeaderRequired.
type UserIdHeaderRequired = string

// ListOrdersParams defines parameters for ListOrders.
type ListOrdersParams struct {
	// Limit Max number of orders to return.
	Limit *LimitQuery `form:"limit,omitempty" json:"limit,omitempty"`

	// PageToken Pagination token returned by previous request.
	PageToken *PageTokenQuery `form:"page_token,omitempty" json:"page_token,omitempty"`

	// XUserId Optional user identifier. If missing, gateway generates a new user_id.
	XUserId *UserIdHeader `json:"X-User-Id,omitempty"`
}

// CreateOrderParams defines parameters for CreateOrder.
type CreateOrderParams struct {
	// XUserId Optional user identifier. If missing, gateway generates a new user_id.
	XUserId *UserIdHeader `json:"X-User-Id,omitempty"`

	// IdempotencyKey Optional idempotency key for safe retries of POST requests.
	IdempotencyKey *IdempotencyKeyHeader `json:"Idempotency-Key,omitempty"`
}

// GetOrderParams defines parameters for GetOrder.
type GetOrderParams struct {
	// XUserId Optional user identifier. If missing, gateway generates a new user_id.
	XUserId *UserIdHeader `json:"X-User-Id,omitempty"`
}

// CreateAccountParams defines parameters for CreateAccount.
type CreateAccountParams struct {
	// XUserId Optional user identifier. If missing, gateway generates a new user_id.
	XUserId *UserIdHeader `json:"X-User-Id,omitempty"`

	// IdempotencyKey Optional idempotency key for safe retries of POST requests.
	IdempotencyKey *IdempotencyKeyHeader `json:"Idempotency-Key,omitempty"`
}

// GetBalanceParams defines parameters for GetBalance.
type GetBalanceParams struct {
	// XUserId Required user identifier for this endpoint.
	XUserId UserIdHeaderRequired `json:"X-User-Id"`
}

// TopUpAccountParams defines parameters for TopUpAccount.
type TopUpAccountParams struct {
	// XUserId Optional user identifier. If missing, gateway generates a new user_id.
	XUserId *UserIdHeader `json:"X-User-Id,omitempty"`

	// IdempotencyKey Optional idempotency key for safe retries of POST requests.
	IdempotencyKey *IdempotencyKeyHeader `json:"Idempotency-Key,omitempty"`
}

// CreateOrderJSONRequestBody defines body for CreateOrder for application/json ContentType.
type CreateOrderJSONRequestBody = CreateOrderRequest

// CreateAccountJSONRequestBody defines body for CreateAccount for application/json ContentType.
type CreateAccountJSONRequestBody = CreateAccountRequest

// TopUpAccountJSONRequestBody defines body for TopUpAccount for application/json ContentType.
type TopUpAccountJSONRequestBody = TopUpAccountRequest

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List orders
	// (GET /orders)
	ListOrders(w http.ResponseWriter, r *http.Request, params ListOrdersParams)
	// Create order (async payment starts)
	// (POST /orders)
	CreateOrder(w http.ResponseWriter, r *http.Request, params CreateOrderParams)
	// Get order status/details
	// (GET /orders/{orderId})
	GetOrder(w http.ResponseWriter, r *http.Request, orderId OrderIdPath, params GetOrderParams)
	// Create account (max 1 per user)
	// (POST /payments/account)
	CreateAccount(w http.ResponseWriter, r *http.Request, params CreateAccountParams)
	// Get account balance
	// (GET /payments/account/balance)
	GetBalance(w http.ResponseWriter, r *http.Request, params GetBalanceParams)
	// Top up account
	// (POST /payments/account/topup)
	TopUpAccount(w http.ResponseWriter, r *http.Request, params TopUpAccountParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List orders
// (GET /orders)
func (_ Unimplemented) ListOrders(w http.ResponseWriter, r *http.Request, params ListOrdersParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create order (async payment starts)
// (POST /orders)
func (_ Unimplemented) CreateOrder(w http.ResponseWriter, r *http.Request, params CreateOrderParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get order status/details
// (GET /orders/{orderId})
func (_ Unimplemented) GetOrder(w http.ResponseWriter, r *http.Request, orderId OrderIdPath, params GetOrderParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create account (max 1 per user)
// (POST /payments/account)
func (_ Unimplemented) CreateAccount(w http.ResponseWriter, r *http.Request, params CreateAccountParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get account balance
// (GET /payments/account/balance)
func (_ Unimplemented) GetBalance(w http.ResponseWriter, r *http.Request, params GetBalanceParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Top up account
// (POST /payments/account/topup)
func (_ Unimplemented) TopUpAccount(w http.ResponseWriter, r *http.Request, params TopUpAccountParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListOrders operation middleware
func (siw *ServerInterfaceWrapper) ListOrders(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListOrdersParams

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "page_token" -------------

	err = runtime.BindQueryParameter("form", true, false, "page_token", r.URL.Query(), &params.PageToken)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "page_token", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "X-User-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-User-Id")]; found {
		var XUserId UserIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-User-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-User-Id", valueList[0], &XUserId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-User-Id", Err: err})
			return
		}

		params.XUserId = &XUserId

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListOrders(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateOrder operation middleware
func (siw *ServerInterfaceWrapper) CreateOrder(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateOrderParams

	headers := r.Header

	// ------------- Optional header parameter "X-User-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-User-Id")]; found {
		var XUserId UserIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-User-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-User-Id", valueList[0], &XUserId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-User-Id", Err: err})
			return
		}

		params.XUserId = &XUserId

	}

	// ------------- Optional header parameter "Idempotency-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Idempotency-Key")]; found {
		var IdempotencyKey IdempotencyKeyHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Idempotency-Key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Idempotency-Key", valueList[0], &IdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Idempotency-Key", Err: err})
			return
		}

		params.IdempotencyKey = &IdempotencyKey

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateOrder(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetOrder operation middleware
func (siw *ServerInterfaceWrapper) GetOrder(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "orderId" -------------
	var orderId OrderIdPath

	err = runtime.BindStyledParameterWithOptions("simple", "orderId", chi.URLParam(r, "orderId"), &orderId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "orderId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetOrderParams

	headers := r.Header

	// ------------- Optional header parameter "X-User-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-User-Id")]; found {
		var XUserId UserIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-User-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-User-Id", valueList[0], &XUserId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-User-Id", Err: err})
			return
		}

		params.XUserId = &XUserId

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetOrder(w, r, orderId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateAccount operation middleware
func (siw *ServerInterfaceWrapper) CreateAccount(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params CreateAccountParams

	headers := r.Header

	// ------------- Optional header parameter "X-User-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-User-Id")]; found {
		var XUserId UserIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-User-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-User-Id", valueList[0], &XUserId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-User-Id", Err: err})
			return
		}

		params.XUserId = &XUserId

	}

	// ------------- Optional header parameter "Idempotency-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Idempotency-Key")]; found {
		var IdempotencyKey IdempotencyKeyHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Idempotency-Key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Idempotency-Key", valueList[0], &IdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Idempotency-Key", Err: err})
			return
		}

		params.IdempotencyKey = &IdempotencyKey

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateAccount(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetBalance operation middleware
func (siw *ServerInterfaceWrapper) GetBalance(w http.ResponseWriter, r *http.Request) {

	var err error

	ctx := r.Context()

	ctx = context.WithValue(ctx, UserIdHeaderAuthScopes, []string{})

	r = r.WithContext(ctx)

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBalanceParams

	headers := r.Header

	// ------------- Required header parameter "X-User-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-User-Id")]; found {
		var XUserId UserIdHeaderRequired
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-User-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-User-Id", valueList[0], &XUserId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: true})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-User-Id", Err: err})
			return
		}

		params.XUserId = XUserId

	} else {
		err := fmt.Errorf("Header parameter X-User-Id is required, but not found")
		siw.ErrorHandlerFunc(w, r, &RequiredHeaderError{ParamName: "X-User-Id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetBalance(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TopUpAccount operation middleware
func (siw *ServerInterfaceWrapper) TopUpAccount(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params TopUpAccountParams

	headers := r.Header

	// ------------- Optional header parameter "X-User-Id" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("X-User-Id")]; found {
		var XUserId UserIdHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "X-User-Id", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "X-User-Id", valueList[0], &XUserId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "X-User-Id", Err: err})
			return
		}

		params.XUserId = &XUserId

	}

	// ------------- Optional header parameter "Idempotency-Key" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("Idempotency-Key")]; found {
		var IdempotencyKey IdempotencyKeyHeader
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "Idempotency-Key", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithOptions("simple", "Idempotency-Key", valueList[0], &IdempotencyKey, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationHeader, Explode: false, Required: false})
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "Idempotency-Key", Err: err})
			return
		}

		params.IdempotencyKey = &IdempotencyKey

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TopUpAccount(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/orders", wrapper.ListOrders)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/orders", wrapper.CreateOrder)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/orders/{orderId}", wrapper.GetOrder)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/payments/account", wrapper.CreateAccount)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/payments/account/balance", wrapper.GetBalance)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/payments/account/topup", wrapper.TopUpAccount)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+RaW2/bRhb+K4PZfXAAWpST7KLLNydRHaGOrdoyuoBrBCPySJqanJnODBVzDf73xVxI",
	"kRRlya0vRfpkUZzLuXznOxfrHsc8E5wB0wpH91gQSTLQIO3TOIFMcA0sLn6C4jOQBKT5PgEVSyo05QxH",
	"+Nx+ICmi6+XoFgo05xIpMgckQUsKCvE5mpxfTpGE33NQWg1wgKk5YumODjAjGeCoefHhT1DgAKt4CRkx",
	"l2eUnQJb6CWOjgKsC2E2KC0pW+CyDPApzaj+OQdZbIr6hdwhlmczkEYWLhOQCmluBMwlq8X53e6upUnN",
	"iS0ZEpiTPNU4+tcwwHMuM6JxhCnT797iAGfkjmZ5hqO3w2Fg5HVPa2kp07AAacU9N0KMkwkxCt27+4V5",
	"qK/nbgUOsLEblZDgSMscHmOUCVnAlN8C22KYCVlQRswD0maZtwgkaFYgIWFFea4qv22zkyAL+Gq3P8ph",
	"V8qotxNduQJpIMY0nVOQAzSeo4wqRdkiQAui4Rsp0AIYSKJBIYIYfLObvtJkK9D+e2huP7TW/WMSX9Q+",
	"6UpevelKbuNCL6lCwBLBKdN7ifdHnV9WS21If5RANBzHMc+ZvnD+NN+TJKHO0BPJBUhNQeFoTlIFQUev",
	"USZ0UWEBzXhSDCo7I6qQJgY/c8kzVIuPnGIB4rJ2kYVW5Tda+3Lwq0GPV4LPfoNY4zLoyq0EZwosYzXE",
	"vcczkhIW2xfNsPz3e9wIxOFmIAbYa9DnRsXT1dqN6EBIvqIJJNu0eTPAfahZO/C6vi2oJb7ZqrRliH1d",
	"1TYHyYy5HrbGUZ81WibYHRBN1fyd7TN2arfNoZb8zId/SpjjCP8jXCes0OM6tGe8phOdlH1KjqTkD6iX",
	"gCY0Vdvd6mJ941gwx5pdHQmf1gSBiUuyIjQlsxR2G8RJ1WeGE9AfHNBfNHavvKqWjSrGclz0VDF6Avo7",
	"h/ApVU5FtUNH+4lqyNTe2vrLiJSkeHXtVa/655X7tlFrW9Bj+z2iDFnMkhTFuZS2Js4Z1QodwGAxQLG1",
	"xy0XEN8qK+ojGTq27Jl8JW16T4iGQ00z2FR+g9U33lsrePNvvFSa6Hw/z166pW1/PuyK+uqg4ZXeVFJL",
	"stVZl7WkwIz9rvHZ6Bcc4B/HZ+PLz6NPOMAfj88+jk5PR58ap6xVnXJxJR5ZI/2V0NGfkfvs1db071BV",
	"GSRDnEuqi0uDWadhs6I/zl0r1ptK6iK+FndFyUahu1dBX3GfoKbFtYU6ZXPeA5rJGJ34Qlny3HQ3n6fT",
	"Sd1Gmw7WETQiLEETUmQGP1ayxcXk4+BX5jRryEkV4lVnZfqRjCtd9yMqahTkfc1VVe6b61ynqBC1sJYe",
	"RL4v+JFLdDKaolB4oULiwBZ6D3mDtSW7GP18Nb4YfXK9QEpj8LD0VvwynhqekKmxsNZCRWHIBTDFcxnD",
	"gMtF6DeFGdWhTTRUp2brCf8fZ6hhURzgFUjlLH00GA6GlgkFMCIojvC7wXDwDge2J7dQCde5bgE2xE2o",
	"2N55nOCokS7trvU85bqfOddLwlYnXAY71zdGHXus7swAyhsTPM5bVpu3w6H5E3OmwXEXESKlsVUt/E25",
	"pLFuOx9KAz01gwV4p7d3oE2p0vXAwVj//RNK0i7Ae4T4QJK6NDygbEVSmiA72UDWeOqNI408y4gsvIP9",
	"7MhEMVkY33pd8E0ZYMFVD/W7dqcaTNj96BvVS+TSGTob/WLjiaiCxUvJGc9VWpi3Uivk48fQTgxKDVzA",
	"V3tTokGiGcQ8A4WqPGeYtE50LpbaUG10YM+O1d5ZosOgtf0HnhRP5vSexrlsJwvTV5UbAXD0PBLsiADk",
	"azl0UHnZOh26WHjzmrHRCQKnn4fxgZUTtaRXb/qCowwq/gzv/Vyz3MqkVWv17NhszmCflRY3msWtkPgr",
	"0KG7+/3L3e1UZ1yjOc9Z0oHcCXja9awXVsOTLTjrlhy2rt2Dmv1yP6YFW+zYaXP1gqQSSFIguKNKq6Cu",
	"gGLO5imN7Ti3j2h9nf09Um2nWSo92z4ruXbblh5A+SUVwb5+MP3n5e4+7kVrP41XyD7IyB06QgKkRX2T",
	"wquuYktwhY0e0ZN5W5xui2Tq/Cod9/9HZCMZ+Anin4qf+t81z83z3XFnLzpcC/RqXP/FdXimTqwK366b",
	"XjwHVLDtZAHfslt3bzbr1zfGne1UUWF6VqNmXyhrLnLRzBZtJDZnJt8Xl/fNvfaqm4fPJMJumGguBCQo",
	"F3+rQmlLkNT4n3KBclGFwBbo27CSqwq47RtOeUzSMIEVcmta85YoDO+XXOkyuhdc6jIkgoarIxzgFZGU",
	"zFKHi2VdbPlfS+DUnGq/tm2y7Lz+YfjD0Kh7Uwu8+WsAH4nK5gzSzO+Us8Dg4dBozpIq8Afr6VutvQm8",
	"Bw92B1pqNBVlYGcU5tkcPAcdL+uXvhptXOOr0PKm/H8AAAD//9xBhX5fIwAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
