// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const insertOutbox = `-- name: InsertOutbox :one
INSERT INTO outbox (topic, kafka_key, payload)
VALUES ($1, $2, $3)
    RETURNING id
`

type InsertOutboxParams struct {
	Topic    string `json:"topic"`
	KafkaKey string `json:"kafka_key"`
	Payload  []byte `json:"payload"`
}

func (q *Queries) InsertOutbox(ctx context.Context, arg InsertOutboxParams) (int64, error) {
	row := q.db.QueryRow(ctx, insertOutbox, arg.Topic, arg.KafkaKey, arg.Payload)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const lockUnsentOutbox = `-- name: LockUnsentOutbox :many
SELECT id, topic, kafka_key, payload, attempts
FROM outbox
WHERE sent_at IS NULL
ORDER BY id
    LIMIT $1
FOR UPDATE SKIP LOCKED
`

type LockUnsentOutboxRow struct {
	ID       int64  `json:"id"`
	Topic    string `json:"topic"`
	KafkaKey string `json:"kafka_key"`
	Payload  []byte `json:"payload"`
	Attempts int32  `json:"attempts"`
}

func (q *Queries) LockUnsentOutbox(ctx context.Context, limit int32) ([]LockUnsentOutboxRow, error) {
	rows, err := q.db.Query(ctx, lockUnsentOutbox, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LockUnsentOutboxRow
	for rows.Next() {
		var i LockUnsentOutboxRow
		if err := rows.Scan(
			&i.ID,
			&i.Topic,
			&i.KafkaKey,
			&i.Payload,
			&i.Attempts,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markOutboxAttemptFailed = `-- name: MarkOutboxAttemptFailed :exec
UPDATE outbox
SET attempts = attempts + 1, last_error = $2, status = 'FAILED'
WHERE id = $1
`

type MarkOutboxAttemptFailedParams struct {
	ID        int64       `json:"id"`
	LastError pgtype.Text `json:"last_error"`
}

func (q *Queries) MarkOutboxAttemptFailed(ctx context.Context, arg MarkOutboxAttemptFailedParams) error {
	_, err := q.db.Exec(ctx, markOutboxAttemptFailed, arg.ID, arg.LastError)
	return err
}

const markOutboxSent = `-- name: MarkOutboxSent :exec
UPDATE outbox
SET sent_at = now(), status = 'SENT'
WHERE id = $1
`

func (q *Queries) MarkOutboxSent(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, markOutboxSent, id)
	return err
}
